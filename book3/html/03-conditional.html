<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="http://thisisdallas.github.io/Simple-Grid/simpleGrid.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="esecuzione-condizionale">Esecuzione condizionale</h1>
<h2 id="espressioni-booleane">Espressioni booleane</h2>
<p>    Un’espressione <em>booleana</em> è un’espressione che può essere o vera o falsa. Gli esempi seguenti usano l’operatore <code>==</code> per la comparazione di due operandi e produrranno <code>True</code> nel caso siano uguali o <code>False</code> in caso contrario:</p>
<pre class="python trinket"><code>&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
{}</code></pre>
<p><code>True</code> e <code>False</code> non sono stringhe ma sono valori speciali che appartengono al tipo <code>bool</code>:      </p>
<pre class="python"><code>&gt;&gt;&gt; type(True)
&lt;class &#39;bool&#39;&gt;
&gt;&gt;&gt; type(False)
&lt;class &#39;bool&#39;&gt;</code></pre>
<p>L’operatore <code>==</code> è uno degli <em>operatori di comparazione</em>; gli altri sono:</p>
<pre class="python"><code>      x != y               # x is not equal to y
      x &gt; y                # x is greater than y
      x &lt; y                # x is less than y
      x &gt;= y               # x is greater than or equal to y
      x &lt;= y               # x is less than or equal to y
      x is y               # x is the same as y
      x is not y           # x is not the same as y</code></pre>
<p>Anche se queste operazioni vi saranno probabilmente familiari, i simboli utilizzati da Python sono diversi da quelli matematici. Un errore comune è l’utilizzare un singolo segno di uguale (<code>=</code>) al posto di un doppio segno di uguale (<code>==</code>). Ricordate che <code>=</code> è un operatore di assegnazione mentre <code>==</code> è un operatore di comparazione. Non esiste un qualcosa di simile a <code>=&lt;</code> o <code>=&gt;</code>.  </p>
<h2 id="operatori-logici">Operatori logici</h2>
<p>  Esistono tre <em>operatori logici</em>: <code>and</code>, <code>or</code> e <code>not</code>. La semantica (significato) di questi operatori è simile al loro significato in inglese. Ad esempio: <code>x&gt; 0 and x &lt;10</code> è TRUE solo se <code>x</code> è maggiore di 0 <em>e</em> minore di 10.</p>
<p>     </p>
<p><code>n%2 == 0 or n%3 == 0</code> è TRUE se si verifica <em>una</em> delle condizioni, cioè se il numero è divisibile per 2 <em>o</em> 3. Infine, l’operatore <code>not</code> nega un’espressione booleana, quindi <code>not (x&gt;y)</code> è true se <code>x&gt;y</code> è false; cioè, se <code>x</code> è minore o uguale a <code>y</code>. In pratica, gli operandi degli operatori logici dovrebbero essere espressioni booleane, ma Python non è molto rigoroso in merito. Qualsiasi numero diverso da zero viene interpretato come “true”:</p>
<pre class="python"><code>&gt;&gt;&gt; 17 and True
True</code></pre>
<p>Questa flessibilità può essere utile, ma ci sono alcuni dettagli che potrebbero creare confusione. Potrebbe essere il caso di evitare un evento del genere, a meno che non si sappia cosa si stia facendo.</p>
<h2 id="esecuzione-condizionale-1">Esecuzione condizionale</h2>
<p>     Per scrivere programmi utili, abbiamo quasi sempre bisogno di verificare le condizioni e modificare di conseguenza il comportamento del programma. Le <em>istruzioni condizionali</em> ci fornisco questa capacità. La forma più semplice è l’istruzione <code>if</code>:</p>
<pre class="python"><code>if x &gt; 0 :
    print(&#39;x is positive&#39;)</code></pre>
<p>L’espressione booleana dopo l’istruzione <code>if</code> è chiamata <em>condizione</em>. Terminiamo l’istruzione <code>if</code> con il carattere due punti (:) e la linea/linee seguenti l’istruzione devono essere indentate (rientrate).</p>
<figure>
<img src="../images/if.svg" alt="If Logic" /><figcaption>If Logic</figcaption>
</figure>
<p>Se la condizione logica è vera, allora verrà eseguita l’istruzione indentata. Se la condizione logica è falsa, l’istruzione indentata verrà saltata.   </p>
<p>Le istruzioni <code>if</code> hanno la stessa struttura delle definizioni di funzione o cicli <code>for</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. L’istruzione consiste in una riga di intestazione che termina con il carattere dei due punti (:) seguito da un blocco indentato. Istruzioni come questa sono chiamate <em>istruzioni composte</em> perché si estendono su più di una riga. Non c’è alcun limite al numero di istruzioni che possono apparire nel blocco, ma deve esserne presente almeno una. Occasionalmente, è utile avere un blocco senza istruzioni (di solito come segnaposto per codice non ancora scritto). In tal caso, puoi usare l’istruzione <code>pass</code>, che non ha alcun effetto.  </p>
<pre class="python"><code>if x &lt; 0 :
    pass          # need to handle negative values!</code></pre>
<p>Se si immette un’istruzione <code>if</code> nell’interprete Python, il prompt cambierà da tre chevron a tre punti per indicare che ci si trova nel mezzo di un blocco di istruzioni, come mostrato di seguito:</p>
<pre class="python"><code>&gt;&gt;&gt; x = 3
&gt;&gt;&gt; if x &lt; 10:
...    print(&#39;Small&#39;)
...
Small
&gt;&gt;&gt;</code></pre>
<p>Quando si utilizza l’interprete Python, è necessario lasciare una riga vuota alla fine di un blocco, in caso contrario Python restituirà un errore:</p>
<pre class="python"><code>&gt;&gt;&gt; x = 3
&gt;&gt;&gt; if x &lt; 10:
...    print(&#39;Small&#39;)
... print(&#39;Done&#39;)
  File &quot;&lt;stdin&gt;&quot;, line 3
    print(&#39;Done&#39;)
        ^
SyntaxError: invalid syntax</code></pre>
<p>Durante la scrittura e l’esecuzione di uno script non è necessaria una riga vuota alla fine di un blocco di istruzioni, ma questa può migliorare la leggibilità del codice.</p>
<h2 id="esecuzione-alternativa">Esecuzione alternativa</h2>
<p>   Una seconda forma dell’istruzione <code>if</code> è l’<em>esecuzione alternativa</em> in cui ci sono due possibilità e la condizione determina quale debba essere eseguita. La sintassi ha questo aspetto:</p>
<pre class="python"><code>if x%2 == 0 :
    print(&#39;x is even&#39;)
else :
    print(&#39;x is odd&#39;)</code></pre>
<p>Quando <code>x</code> è diviso per 2, se il resto è 0, allora sappiamo che <code>x</code> è pari e il programma visualizza un messaggio in tal senso. Se la condizione è falsa, viene eseguita la seconda serie di istruzioni.</p>
<figure>
<img src="../images/if-else.svg" alt="If-Then-Else Logic" /><figcaption>If-Then-Else Logic</figcaption>
</figure>
<p>Poiché una condizione deve necessariamente essere vera o falsa, verrà eseguita esattamente una delle alternative. Le alternative sono chiamate <em>branches</em>, perché sono come rami nel flusso di esecuzione. </p>
<h2 id="condizioni-concatenate">Condizioni concatenate</h2>
<p>  A volte ci sono più di due possibilità e abbiamo bisogno di più di due branches. Un modo per esprimere un simile calcolo è una condizione <em>concatenata</em>:</p>
<pre class="python"><code>if x &lt; y:
    print(&#39;x is less than y&#39;)
elif x &gt; y:
    print(&#39;x is greater than y&#39;)
else:
    print(&#39;x and y are equal&#39;)</code></pre>
<p><code>elif</code> è un’abbreviazione di&quot; else if &quot;. Anche stavolta verrà eseguito esattamente un ramo.</p>
<figure>
<img src="../images/elif.svg" alt="If-Then-ElseIf Logic" /><figcaption>If-Then-ElseIf Logic</figcaption>
</figure>
<p>Non c’è limite al numero di istruzioni <code>elif</code>. Se esiste una condizione <code>else</code>, deve essere messa alla fine, ma non deve essercene necessariamente una.  </p>
<pre class="python"><code>if choice == &#39;a&#39;:
    print(&#39;Bad guess&#39;)
elif choice == &#39;b&#39;:
    print(&#39;Good guess&#39;)
elif choice == &#39;c&#39;:
    print(&#39;Close, but not correct&#39;)</code></pre>
<p>Ogni condizione viene controllata in ordine. Se la prima condizione è falsa, verrà controllata la successiva e così via. Se una tra queste condizioni risulta vera, verrà eseguito il branch corrispondente e l’istruzione sarà terminata. Anche se più di una condizione è vera, verrà eseguito solo il primo branch vero.</p>
<h2 id="condizioni-nidificate">Condizioni nidificate</h2>
<p>  Una condizione può anche essere annidata in un’altra. Avremmo potuto scrivere l’esempio a tre branches in questo modo:</p>
<pre class="python"><code>if x == y:
    print(&#39;x and y are equal&#39;)
else:
    if x &lt; y:
        print(&#39;x is less than y&#39;)
    else:
        print(&#39;x is greater than y&#39;)</code></pre>
<p>La condizione esterna contiene due branches. Il primo branch contiene una semplice istruzione. Il secondo branch contiene un’altra istruzione <code>if</code>, che ha due branches propri. Questi due branches sono entrambi semplici istruzioni, sebbene potessero essere anche istruzioni condizionali.</p>
<figure>
<img src="../images/nested.svg" alt="Nested If Statements" /><figcaption>Nested If Statements</figcaption>
</figure>
<p>Sebbene l’indentazione delle istruzioni renda la struttura visivamente più intuitiva, le <em>condizioni nidificate</em> diventano difficili da leggere molto rapidamente. In generale, è una buona idea evitarli quando è possibile. Gli operatori logici forniscono spesso un modo per semplificare le istruzioni con condizioni nidificate. Ad esempio, possiamo riscrivere il seguente codice usando una singola condizione:</p>
<pre class="python"><code>if 0 &lt; x:
    if x &lt; 10:
        print(&#39;x is a positive single-digit number.&#39;)</code></pre>
<p>L’istruzione <code>print</code> viene eseguita solo se vengono soddisfatte entrambe le condizioni, quindi possiamo ottenere lo stesso effetto con l’operatore <code>and</code>:</p>
<pre class="python"><code>if 0 &lt; x and x &lt; 10:
    print(&#39;x is a positive single-digit number.&#39;)</code></pre>
<h2 id="gestione-delle-eccezioni-usando-try-ed-except">Gestione delle eccezioni usando try ed except</h2>
<p>In precedenza abbiamo esaminato un segmento di codice in cui abbiamo utilizzato le funzioni <code>input</code> e <code>int</code> per leggere e analizzare un numero intero inserito dall’utente. Abbiamo anche visto che questo potrebbe risultare insidioso:</p>
<pre class="python"><code>&gt;&gt;&gt; prompt = &quot;What...is the airspeed velocity of an unladen swallow?\n&quot;
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10:
&gt;&gt;&gt;</code></pre>
<p>Quando vengono eseguite queste istruzioni nell’interprete Python, si riceve un nuovo prompt dall’interprete, come se pensasse “oops” e passasse all’istruzione successiva. Tuttavia, se si inserisce questo codice in uno script Python e si verifica questo errore, lo script si ferma immediatamente nel suo percorso con un traceback. Non esegue l’istruzione successiva. </p>
<p>Ecco un programma di esempio per convertire una temperatura da Fahrenheit a Celsius:   </p>
<pre class="python"><code>inp = input(&#39;Enter Fahrenheit Temperature: &#39;)
fahr = float(inp)
cel = (fahr - 32.0) * 5.0 / 9.0
print(cel)

# Code: http://www.py4e.com/code3/fahren.py</code></pre>
<p>Se eseguiamo questo codice e gli diamo input non validi, fallirà semplicemente con un messaggio di errore poco amichevole:</p>
<pre><code>python fahren.py
Enter Fahrenheit Temperature:72
22.22222222222222</code></pre>
<pre><code>python fahren.py
Enter Fahrenheit Temperature:fred
Traceback (most recent call last):
  File &quot;fahren.py&quot;, line 2, in &lt;module&gt;
    fahr = float(inp)
ValueError: could not convert string to float: &#39;fred&#39;</code></pre>
<p>Esiste una struttura di esecuzione condizionale incorporata in Python che serve a gestire questi tipi di errori previsti e inaspettati chiamati “try / except”. La finalità di <code>try</code> e <code>except</code> è collegata al sapere in anticipo che alcune sequenze di istruzioni potrebbero incontrare problemi e pertanto si possono aggiungere alcune istruzioni da eseguire in caso di errore. Queste istruzioni aggiuntive (il blocco except) vengono ignorate se non ci sono errori. Potreste pensare alla funzione <code>try</code> e <code>except</code> in Python come una “polizza assicurativa” su una sequenza di istruzioni. Ad esempio, possiamo riscrivere il codice del nostro convertitore di temperatura come segue:</p>
<pre class="python"><code>inp = input(&#39;Enter Fahrenheit Temperature:&#39;)
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print(cel)
except:
    print(&#39;Please enter a number&#39;)

# Code: http://www.py4e.com/code3/fahren2.py</code></pre>
<p>Python inizia eseguendo la sequenza di istruzioni nel blocco <code>try</code>. Se tutto va bene, salta il blocco <code>except</code> e procede. Se si verifica un’eccezione nel blocco <code>try</code>, Python salta fuori dal blocco <code>try</code> ed esegue la sequenza di istruzioni nel blocco <code>except</code>.</p>
<pre><code>python fahren2.py
Enter Fahrenheit Temperature:72
22.22222222222222</code></pre>
<pre><code>python fahren2.py
Enter Fahrenheit Temperature:fred
Please enter a number</code></pre>
<p>Gestire un’eccezione con un’istruzione <code>try</code> è detto <em>catching</em> di un’eccezione. In questo esempio, la condizione <code>except</code> stampa un messaggio di errore. In generale, catturare un’eccezione vi dà la possibilità o di risolvere il problema o di riprovare o almeno di terminare il programma elegantemente.</p>
<h2 id="valutazione-di-un-cortocircuito-di-espressioni-logiche">Valutazione di un cortocircuito di espressioni logiche</h2>
<p> Quando Python sta elaborando un’espressione logica come <code>x&gt; = 2 and (x/y)&gt; 2</code>, calcola l’espressione da sinistra a destra. A causa della definizione di <code>and</code>, se <code>x</code> è minore di 2, l’espressione <code>x&gt; = 2</code> è <code>False</code> e ​​quindi l’intera espressione è <code>False</code> indipendentemente dal fatto che <code>(x/y)&gt; 2</code> restituisca <code>True</code> o <code>False</code>. Quando Python rileva che non c’è nulla da guadagnare valutando il resto di un’espressione logica, interrompe la sua valutazione e non esegue i calcoli nel resto di questa. Quando la valutazione di un’espressione logica si arresta perché il valore complessivo è già noto, viene chiamato <em>cortocircuito</em> della valutazione.</p>
<p>  Anche se questo può sembrare una sottigliezza, il comportamento di cortocircuito porta a una tecnica intelligente chiamata <em>schema del guardiano</em>. Considerate la seguente sequenza di codice nell’interprete Python:</p>
<pre class="python"><code>&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 2
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
True
&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
False
&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ZeroDivisionError: division by zero
&gt;&gt;&gt;</code></pre>
<p>Il terzo calcolo non è riuscito perché Python stava calcolando <code>(x / y)</code> e <code>y</code> era zero, il che causa un errore di runtime. Ma il secondo esempio <em>non</em> ha fallito perché la prima parte dell’espressione <code>x&gt;=2</code> è stata calcolata come <code>False</code> quindi <code>(x / y)</code> non è mai stato eseguito a causa della regola del <em>cortocircuito</em> e non c’erano errori. Possiamo costruire l’espressione logica per posizionare strategicamente un calcolo <em>guard</em> appena prima del calcolo che potrebbe causare un errore, come di seguito:</p>
<pre class="python"><code>&gt;&gt;&gt; x = 1
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and y != 0 and (x/y) &gt; 2
False
&gt;&gt;&gt; x = 6
&gt;&gt;&gt; y = 0
&gt;&gt;&gt; x &gt;= 2 and y != 0 and (x/y) &gt; 2
False
&gt;&gt;&gt; x &gt;= 2 and (x/y) &gt; 2 and y != 0
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ZeroDivisionError: division by zero
&gt;&gt;&gt;</code></pre>
<p>Nella prima espressione logica, <code>x&gt;=2</code> è <code>False</code>, quindi il calcolo si ferma su <code>and</code>. Nella seconda espressione logica, <code>x&gt;=2</code> è <code>True</code> ma <code>y!= 0</code> è <code>False</code> quindi non raggiungiamo mai <code>(x/y)</code>. Nella terza espressione logica, il <code>y != 0</code> viene <em>dopo</em> il calcolo <code>(x/y)</code> pertanto l’espressione fallisce con un errore. Nella seconda espressione, diciamo che <code>y != 0</code> funge da <em>guardia</em> per assicurare che <code>(x/y)</code> venga eseguito solo se <code>y</code> è diverso da zero.</p>
<h2 id="debug">Debug</h2>
<p>  Il traceback di Python viene visualizzato quando si verifica un errore che contiene molte informazioni che possono essere difficili da gestire. Le parti più utili sono di solito:</p>
<ul>
<li>che tipo di errore era, e</li>
<li>dove si è verificato.</li>
</ul>
<p>Gli errori di sintassi sono solitamente facili da trovare, ma ci sono alcuni tranelli. Gli errori di spaziatura possono essere difficoltosi perché gli spazi e le tabulazioni sono invisibili e siamo abituati ad ignorarli. </p>
<pre class="python"><code>&gt;&gt;&gt; x = 5
&gt;&gt;&gt;  y = 6
  File &quot;&lt;stdin&gt;&quot;, line 1
    y = 6
    ^
IndentationError: unexpected indent</code></pre>
<p>In questo esempio, il problema è che la seconda riga è rientrata di uno spazio. Ma il messaggio di errore punta ad <code>y</code> e ciò può essere fuorviante. In generale, i messaggi di errore indicano dove è stato rilevato il problema, ma l’errore effettivo potrebbe essere precedente nel codice, a volte su una riga precedente. In generale, i messaggi di errore indicano dove è stato scoperto il problema, ma spesso quel punto non indica dove è stato causato.</p>
<h2 id="glossario">Glossario</h2>
<dl>
<dt>blocco</dt>
<dd>la sequenza di istruzioni all’interno di un’istruzione composta. 
</dd>
<dt>espressione booleana</dt>
<dd>Un’espressione <em>booleana</em> è un’espressione che può essere o vera o falsa.  
</dd>
<dt>branch</dt>
<dd>una delle sequenze di istruzioni alternative in un’istruzione condizionale. 
</dd>
<dt>condizione concatenata</dt>
<dd>un’istruzione condizionale con una serie di branches alternativi.  
</dd>
<dt>operatore di comparazione</dt>
<dd>uno degli operatori che confronta i suoi operandi: <code>==</code>, <code>!=</code>,<code>&gt;</code>,<code>&lt;</code>,<code>&gt; =</code>, e<code>&lt;=</code>.
</dd>
<dt>istruzione condizionale</dt>
<dd>una istruzione che controlla il flusso di esecuzione in base ad alcune condizioni.  
</dd>
<dt>condizione</dt>
<dd>l’espressione booleana in un’istruzione condizionale che determina quale branc viene eseguito. 
</dd>
<dt>compound statement</dt>
<dd>Un’istruzione che composta da un’intestazione e un corpo. L’intestazione termina con due punti (:). Il corpo è rientrato rispetto all’intestazione. 
</dd>
<dt>schema guardiano</dt>
<dd>quando costruiamo un’espressione logica con comparazioni aggiuntive per sfruttare il comportamento di cortocircuito.  
</dd>
<dt>operatore logico</dt>
<dd>uno degli operatori che combina espressioni booleane: <code>and</code>, <code>or</code>, e <code>not</code>. condizionale nidificato: un’istruzione condizionale che appare in uno dei branches di un’altra istruzione condizionale.  
</dd>
<dt>traceback</dt>
<dd>un elenco delle funzioni che sono in esecuzione che verranno visualizzate quando si verifica un’eccezione. 
</dd>
<dt>cortocircuito</dt>
<dd>quando Python è a metà strada nel calcolo di un’espressione logica e interrompe il calcolo perché Python conosce il valore finale dell’espressione senza dover calcolare il resto dell’espressione. 
</dd>
</dl>
<h2 id="esercizi">Esercizi</h2>
<p><strong>Esercizio 1:</strong> Riscrivete il vostro calcolo della retribuzione per attribuire ad un dipendente una maggiorazione oraria di 1,5 volte, per le ore lavorate superiori a 40.</p>
<pre><code>Enter Hours: 45
Enter Rate: 10
Pay: 475.0</code></pre>
<p><strong>Esercizio 2:</strong> Riscrivete il vostro programma di calcolo della retribuzione usando <code>try</code> e <code>except</code> in modo che il tuo programma gestisca input non-numerici in maniera elegante stampando un messaggio ed uscendo dal programma. Di seguito vengono mostrate due esecuzioni del programma:</p>
<pre><code>Enter Hours: 20
Enter Rate: nine
Error, please enter numeric input</code></pre>
<pre><code>Enter Hours: forty
Error, please enter numeric input</code></pre>
<p><strong>Esercizio 3:</strong> scrivete un programma per richiedere un punteggio compreso tra 0.0 e 1.0. Se il punteggio non è compreso nell’intervallo, visualizzate un messaggio di errore. Se il punteggio è compreso tra 0,0 e 1,0, visualizzate un voto utilizzando la seguente tabella:</p>
<pre><code> Score   Grade
&gt;= 0.9     A
&gt;= 0.8     B
&gt;= 0.7     C
&gt;= 0.6     D
 &lt; 0.6     F</code></pre>
<pre><code>Enter score: 0.95
A</code></pre>
<pre><code>Enter score: perfect
Bad score</code></pre>
<pre><code>Enter score: 10.0
Bad score</code></pre>
<pre><code>Enter score: 0.75
C</code></pre>
<pre><code>Enter score: 0.5
F</code></pre>
<p>Eseguite ripetutamente il programma per testare i diversi valori di input.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Impareremo a conoscere le funzioni nel Capitolo 4 e i cicli nel Capitolo 5.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
</body>
</html>
